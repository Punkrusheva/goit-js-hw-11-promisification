{"version":3,"sources":["webpack:///./theory.js"],"names":["getMessage","input","prompt","Promise","resolve","logger","message","console","log","then"],"mappings":"0HA2KMA,EAAa,WACjB,IAAMC,EAAQC,OAAO,qBAErB,OAAOC,QAAQC,QAAQH,IAGnBI,EAAS,SAAAC,GAAO,OAAIC,QAAQC,IAAIF,IAEtCN,IAAaS,MAAK,SAAAH,GAAO,OAAID,EAAOC,MAGpCN,IAAaS,KAAKJ,K","file":"main.9872d78e4976337303e4.js","sourcesContent":["//then\r\n/*const promise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    /*\r\n     * Если какое-то условие выполняется, то есть все хорошо,\r\n     * вызываем resolve и получает данные. Условие зависит от задачи.\r\n     */\r\n    /*resolve('Data passed into resolve function :)');\r\n\r\n    // Если что-то не так, вызваем reject и передаем ошибку\r\n    // reject(\"Error passed into reject function :(\")\r\n  }, 2000);\r\n});\r\n\r\n// Выполнится мгновенно\r\nconsole.log('BEFORE promise.then');\r\n\r\nconst onResolve = data => {\r\n  console.log('INSIDE promise.then - onResolve');\r\n  console.log(data); // \"Data passed into resolve function :)\"\r\n};\r\n\r\nconst onReject = error => {\r\n  console.log('INSIDE promise.then - onReject');\r\n  console.log(error); // \"Error passed into reject function :(\"\r\n};\r\n\r\npromise.then(\r\n  // будет вызвана через 2 секунды, если обещание выполнится успешно\r\n  onResolve,\r\n  // будет вызвана через 2 секунды, если обещание выполнится с ошибкой\r\n  onReject,\r\n);\r\n\r\n// Выполнится мгновенно\r\nconsole.log('AFTER promise.then');\r\n\r\n\r\n/*\r\nconst promise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    // Если все ок, то вызывается resolve и передаем данные\r\n    resolve('Data passed into resolve function :)');\r\n\r\n    // Если что-то не так, вызваем reject и передаем ошибку\r\n    // reject(\"Error passed into reject function :(\")\r\n  }, 2000);\r\n});\r\n\r\n// Выполнится мгновенно\r\nconsole.log('BEFORE promise.then');\r\n\r\npromise.then(\r\n  // Будет вызвана через 2 секунды, если обещание выполнится успешно\r\n  data => {\r\n    console.log('INSIDE promise.then - onResolve');\r\n    console.log(data); // \"Data passed into resolve function :)\"\r\n  },\r\n  // Будет вызвана через 2 секунды, если обещание выполнится с ошибкой\r\n  error => {\r\n    console.log('INSIDE promise.then - onReject');\r\n    console.log(error); // \"Error passed into reject function :(\"\r\n  },\r\n);\r\n\r\n// Выполнится мгновенно\r\nconsole.log('AFTER promise.then');\r\n\r\n//catch\r\nconst promise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    reject('There was an error :(');\r\n  }, 2000);\r\n});\r\n\r\n/*\r\n * then не выполнится так как в функции fn, внутри new Promise(fn),\r\n * был вызван reject(). А catch как раз выполнится через 2 секунды\r\n */\r\n/*promise\r\n  .then(data => {\r\n    console.log(data);\r\n  })\r\n  .catch(error => {\r\n    console.log(error);\r\n  });\r\n\r\n//finally\r\nconst promise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve('success!');\r\n  }, 2000);\r\n});\r\n\r\npromise\r\n  .then(data => console.log(data)) // \"success\"\r\n  .catch(error => console.log(error))\r\n  .finally(() => console.log('finished!')); // \"finished\"*/\r\n\r\n  //Цепочки промисов\r\n/*const promise = new Promise((resolve, reject) => {\r\n  setTimeout(() => {\r\n    resolve(5);\r\n  }, 2000);\r\n});\r\n\r\npromise\r\n  .then(value => {\r\n    console.log(value); // 5\r\n    return value * 2;\r\n  })\r\n  .then(value => {\r\n    console.log(value); // 10\r\n    return value * 3;\r\n  })\r\n  .then(value => {\r\n    console.log(value); // 30\r\n  })\r\n  .catch(error => {\r\n    console.log(error);\r\n  });\r\n\r\n  //Promise.all()\r\n  const makePromise = (text, delay) => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => resolve(text), delay);\r\n  });\r\n};\r\n\r\nconst promiseA = makePromise('promiseA', 1000);\r\nconst promiseB = makePromise('promiseB', 3000);\r\n\r\n/*\r\n * Выполнится спустя 3 секунды, когда выполнится второй промис с задержкой в 3c.\r\n * Первый выполнится через секунду и просто будет готов\r\n */\r\n/*Promise.all([promiseA, promiseB])\r\n  .then(result => console.log(result)) //[\"promiseA\", \"promiseB\"]\r\n  .catch(err => console.log(err));\r\n*/\r\n\r\n  //Promise.race()\r\n  /*const makePromise = (text, delay) => {\r\n  return new Promise(resolve => {\r\n    setTimeout(() => resolve(text), delay);\r\n  });\r\n};\r\n\r\nconst promiseA = makePromise('promiseA', 1000);\r\nconst promiseB = makePromise('promiseB', 3000);\r\n\r\n/*\r\n * Выполнится спустя 1 секунду, когда выполнится самый быстрый promiseA\r\n * с задержкой в 1c. Второй промис promiseB будет проигнорирован\r\n */\r\n/*Promise.race([promiseA, promiseB])\r\n  .then(result => console.log(result)) // \"promiseA\"\r\n  .catch(err => console.log(err));\r\n\r\n\r\n  //Promise.resolve()\r\n  const getMessage = function(callback) {\r\n  const input = prompt('Введите сообщение');\r\n\r\n  callback(input);\r\n};\r\n\r\nconst logger = message => console.log(message);\r\n\r\ngetMessage(logger);*/\r\n//превращается\r\nconst getMessage = function() {\r\n  const input = prompt('Введите сообщение');\r\n\r\n  return Promise.resolve(input);\r\n};\r\n\r\nconst logger = message => console.log(message);\r\n\r\ngetMessage().then(message => logger(message));\r\n\r\n// Или еще короче\r\ngetMessage().then(logger);"],"sourceRoot":""}